
# say.proto 接口文档

*Document generated by protoc-gen-markdown. DO NOT EDIT.*

> 接口列表


* [SayService](#sayservice) - ***TODO***


	* [Hello](#hello) - ***TODO***


	* [Update](#update) - ***TODO***





<h2 id="sayservice">SayService</h2>

> 



<h3 id="hello">Hello</h3>

> 



* 请求类型: ***HelloRequest***

> 

|字段|protobuf 类型|json 类型|说明|默认值|是否必传|
|---|---|---|---|---|---|
|name|string|string|	请求名称|-|false|




* 返回类型: ***HelloResponse***

> 

|字段|protobuf 类型|json 类型|说明|默认值|是否必传|
|---|---|---|---|---|---|
|code|int|number/string|***TODO***|-|false|
|msg|string|string|***TODO***|-|false|
|data|array [[Data](#data)]|array|***TODO***|-|false|






<h3 id="update">Update</h3>

> 



* 请求类型: ***UpdateRequest***

> 

|字段|protobuf 类型|json 类型|说明|默认值|是否必传|
|---|---|---|---|---|---|
|name|string|string|***TODO***|-|false|




* 返回类型: ***UpdateResponse***

> 

|字段|protobuf 类型|json 类型|说明|默认值|是否必传|
|---|---|---|---|---|---|
|code|int|number/string|***TODO***|-|false|
|msg|string|string|***TODO***|-|false|








********

## *Embed Messages*





<h3 id="eplat">Eplat</h3>

> 

* 枚举说明

|枚举名称 (string)|枚举数值 (integer)|说明|
|---|---|---|
|EPLAT_UNSPECIFIED|0|	开发心|
|EPLAT_UNKNOWN|1|***TODO***|
|EPLAT_WEB|2|***TODO***|
|EPLAT_M|3|***TODO***|
|EPLAT_ANDROID|4|***TODO***|
|EPLAT_IOS|5|***TODO***|








<h3 id="data">Data</h3>

> 

* 字段说明

|字段|protobuf 类型|json 类型|说明|默认值|是否必传|
|---|---|---|---|---|---|
|plat|enum [Eplat](#eplat)|string/integer|***TODO***|-|false|
|confmsg|string|string|***TODO***|-|false|
|order_time|[Timestamp](#timestamp)|string ("1972-01-01T10:00:20.021Z")|***TODO***|-|false|


<h3 id="timestamp">Timestamp</h3>

>  A Timestamp represents a point in time independent of any time zone or local
>  calendar, encoded as a count of seconds and fractions of seconds at
>  nanosecond resolution. The count is relative to an epoch at UTC midnight on
>  January 1, 1970, in the proleptic Gregorian calendar which extends the
>  Gregorian calendar backwards to year one.
> 
>  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
>  second table is needed for interpretation, using a [24-hour linear
>  smear](https://developers.google.com/time/smear).
> 
>  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
>  restricting to that range, we ensure that we can convert to and from [RFC
>  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
> 
>  # Examples
> 
>  Example 1: Compute Timestamp from POSIX `time()`.
> 
>      Timestamp timestamp;
>      timestamp.set_seconds(time(NULL));
>      timestamp.set_nanos(0);
> 
>  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
> 
>      struct timeval tv;
>      gettimeofday(&tv, NULL);
> 
>      Timestamp timestamp;
>      timestamp.set_seconds(tv.tv_sec);
>      timestamp.set_nanos(tv.tv_usec * 1000);
> 
>  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
> 
>      FILETIME ft;
>      GetSystemTimeAsFileTime(&ft);
>      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
> 
>      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
>      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
>      Timestamp timestamp;
>      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
>      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
> 
>  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
> 
>      long millis = System.currentTimeMillis();
> 
>      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
>          .setNanos((int) ((millis % 1000) * 1000000)).build();
> 
> 
>  Example 5: Compute Timestamp from current time in Python.
> 
>      timestamp = Timestamp()
>      timestamp.GetCurrentTime()
> 
>  # JSON Mapping
> 
>  In JSON format, the Timestamp type is encoded as a string in the
>  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
>  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
>  where {year} is always expressed using four digits while {month}, {day},
>  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
>  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
>  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
>  is required. A proto3 JSON serializer should always use UTC (as indicated by
>  "Z") when printing the Timestamp type and a proto3 JSON parser should be
>  able to accept both UTC and other timezones (as indicated by an offset).
> 
>  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
>  01:30 UTC on January 15, 2017.
> 
>  In JavaScript, one can convert a Date object to this format using the
>  standard
>  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
>  method. In Python, a standard `datetime.datetime` object can be converted
>  to this format using
>  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
>  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
>  the Joda Time's [`ISODateTimeFormat.dateTime()`](
>  http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
>  ) to obtain a formatter capable of generating timestamps in this format.

* 字段说明

|字段|protobuf 类型|json 类型|说明|默认值|是否必传|
|---|---|---|---|---|---|
|seconds|int64|string| Represents seconds of UTC time since Unix epoch<br> 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to<br> 9999-12-31T23:59:59Z inclusive.|-|false|
|nanos|int|number/string| Non-negative fractions of a second at nanosecond resolution. Negative<br> second values with fractions must still have non-negative nanos values<br> that count forward in time. Must be from 0 to 999,999,999<br> inclusive.|-|false|





